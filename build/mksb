#!/usr/bin/env python

from subprocess import call

import argparse
import importlib
import os
import subprocess
import sys

def write_sb_var(f, var, val):
    if val is None:
        f.write("#%s= unset\n" % var)
        return
    f.write("%s='%s'\n" % (var, val))

def is_internal_repo(url):
    company = "ixsystems.com"

    if url.find(company) == -1:
        return False
    else:
        return True

    
def my_check_call(*args, **kwargs):
    print "args: %s | %s" % (args, dict(**kwargs))
    subprocess.check_call(*args, **kwargs)

def add_second_options(parser):
    parser.add_argument('--avatar-project',
        dest='avatar_project',
        help='specify product (FreeNAS/TrueNAS)',
        default='freenas')

    parser.add_argument('--sandbox-name', '-n', help='checkout name',
                        required=True)

    parser.add_argument('--repo-url',
    help='specify the main repo url (eg: https://github.com/freenas/freenas',
        default='git@gitserver.ixsystems.com:/git/repos/freenas-build/freenas.git')

    parser.add_argument('--repo-cache',
        help='specify a local cache to speed up initial checkout')

    parser.add_argument('--branch', '-b',
        help='specify the checkout branch')

    parser.add_argument('--tag', '-t',
        help='specify the checkout tag')

    # XXX: this should be inside the per-avatar modules.
    # we can fix this later by forcing --avatar-project first.

    parser.add_argument('--freebsd-branch',
	help='specify branch of freebsd to pull')
    parser.add_argument('--freebsd-repo',
	help='specify path to freebsd repo')
    parser.add_argument('--freebsd-repo-cache',
	help='specify path to freebsd repo cache')

    parser.add_argument('--ports-branch',
	help='specify branch of ports to pull')
    parser.add_argument('--ports-repo',
	help='specify path to ports repo')
    parser.add_argument('--ports-repo-cache',
	help='specify path to ports repo')


def main():
    # Since we derive the "avatar_project" from the command line which THEN
    # sets defaults for some common arguments we then need to parse the arguments
    # twice, because it seems like defaults are set at the time of the actual
    # argparse not based defaults in the backing parser object.
    
    
    # Make our first parser to get the "avatar_project"
    avatar_parser = argparse.ArgumentParser(description='Checkout a sandbox.')
    add_second_options(avatar_parser)
    avatar_arg = avatar_parser.parse_args()
    avatar_project = avatar_arg.avatar_project
    
    # OK, now make a second that we will set defaults and other thigns via
    # the module we load for that avatar
    parser = argparse.ArgumentParser(description='Checkout a sandbox.')
    add_second_options(parser)
    
    # our default is FreeNAS, but if an alternate avatar project is specified then
    # bring in those defaults instead.
    '''
    if True:
        args = parser.parse_args()
        avatar_project=args.avatar_project.lower()
    else:
        args= argparse.Namespace()
        avatar_project='freenas'
    '''
    avatar_conf = importlib.import_module('avatar.%s' % avatar_project) #, 'avatar')
    avatar_conf.setup_arg_parser(parser)
    
    args = parser.parse_args()
    
    url = args.repo_cache
    if url is None:
        url = args.repo_url
    
    # Workflow is:
    # Clone from cache if it exists.  If no cache, then just use the actual repo.
    # Update the remote 'origin' to point to the actual repo.
    # Git pull any refs to get up to date in case the cache is out of date in respect to
    #   the actual repo.
    # Checkout the branch.
    #
    # If we use a cache we do not do a -b branch to checkout initially because the specified
    # branch may not be in the cache.  For now we actually never '-b branch' to save time 
    # writing this script!  XXX: someone fix that?
    
    # do the initial clone
    sandbox_name = args.sandbox_name
    if sandbox_name is None:
        sandbox_name = avatar_project

    if os.path.exists(sandbox_name):
        print("Cannot create sandbox %s because it already exists."
              % (sandbox_name))
    os.mkdir(sandbox_name)
    os.chdir(sandbox_name)
    f = open(".sandbox-env", "w")
    
    write_sb_var(f, "GIT_FREEBSD_BRANCH", args.freebsd_branch)
    write_sb_var(f, "GIT_FREEBSD_REPO", args.freebsd_repo)
    write_sb_var(f, "GIT_FREEBSD_CACHE", args.freebsd_repo_cache)
    write_sb_var(f, "GIT_PORTS_BRANCH", args.ports_branch)
    write_sb_var(f, "GIT_PORTS_REPO", args.ports_repo)
    write_sb_var(f, "GIT_PORTS_CACHE", args.ports_repo_cache)
    write_sb_var(f, "SB_BUILD_DIR", avatar_project)
    
    f.close()
    
    
    my_check_call("git clone %s %s" % (url, avatar_project), shell=True)

    # XX: This .git-repo-setting should later move out of avatar_project
    #     and into the sandbox root.
    f = open(avatar_project + "/.git-repo-setting", "w")
    if is_internal_repo(url):
        f.write("INTERNAL")
    else:
        f.write("EXTERNAL")

    f.close() 
    
    # update the origin to point to actual repo
    os.chdir(avatar_project)
    if url != args.build_repo:
        my_check_call("git remote set-url origin %s" % args.build_repo, shell=True)
    
    # get any missing tags or branches from the repo
    my_check_call("git fetch --all", shell=True)
    # get the branch
    if args.branch:
        my_check_call("git checkout %s" % args.branch, shell=True)

    checkout_cmd="make checkout "
    if args.branch:
        checkout_cmd += ('BRANCH="%s" ' % (args.branch))

    if args.branch:
        checkout_cmd += ('TAG="%s" ' % (args.tag))

    print(os.getcwd())
    my_check_call(checkout_cmd, shell=True)
 
    # go back to sandbox level
    os.chdir("..")
    print ""
    print "========================================"
    print "->>> Now run: workon %s" % sandbox_name
    print "========================================"


if __name__ == "__main__":
    main()
